input {
  beats {
    port => 5044
  }
}

filter {
  # =======================================================
  # 區塊 1: 既有的 JSP/TV Log 處理
  # =======================================================
  if [log_type] == "tv_log" {

    grok {
      match => {
        "message" => "^\[%{LOGLEVEL:log_level}\s*\]\s+\[(?<log_raw_date>.+)\s+(?<logger_class>\S+)\]\s+:\s+%{GREEDYDATA:msg_body}"
      }
    }

    # 使用者行為解析
    if [msg_body] =~ "使用者" {
      grok {
        match => {
          "msg_body" => "使用者\[%{DATA:user_name}\]IP\[%{IP:src_ip}\]向\[%{DATA:request_url}\]發出請求（耗時\[%{NUMBER:duration_sec}\]秒）"
        }
      }
    }

    # 只移除特定 IP 的連線錯誤
    if [message] =~ "122.147.5.176" {
      drop {}
    }


    date {
      match => [ "log_raw_date", "yyyy/MM/dd HH:mm:ss:SSS", "yyyy/MM/dd HH:mm:ss" ]
      target => "@timestamp"
      timezone => "Asia/Taipei"
    }

  }

  # =======================================================
  # 區塊 2:  VCS Spring Boot Log 處理
  # =======================================================
  else if [log_type] == "vcs_spring_log" {

    # 1. Spring Boot Grok 解析
    # Log 格式: 2025-12-21 14:27:16.560 [http-nio-8000-exec-2] ERROR c.tkb.controller.LogTestController - 訊息...
    grok {
      match => {
        "message" => "^%{TIMESTAMP_ISO8601:log_raw_date}\s+\[%{DATA:thread_name}\]\s+%{LOGLEVEL:log_level}\s+%{JAVACLASS:logger_class}\s+-\s+%{GREEDYDATA:msg_body}"
      }
    }

    # 2. 進階：嘗試從 msg_body 提取「錯誤原因」(給 AI 分析)
    # 針對範例: "...原因: / by zero"
    if [msg_body] =~ "原因:" {
      grok {
        match => {
          "msg_body" => "原因:\s*(?<error_reason>[^\r\n]+)"
        }
      }
    }

    # 3. 時間處理 (Spring Boot 預設格式通常是 ISO8601 類似格式)
    date {
      match => [ "log_raw_date", "yyyy-MM-dd HH:mm:ss.SSS" ]
      target => "@timestamp"
      timezone => "Asia/Taipei"
    }
  }

  # =======================================================
  # 區塊 3:  GO-API Spring Boot Log 處理
  # =======================================================
  else if [log_type] == "go_spring_log" {

    # 1. GO Spring Boot Grok 解析
    # Log 格式: 2026-01-12 09:23:45,731 WARN  [thread] Class: msg
    grok {
      match => {
        "message" => "^(?<log_raw_date>%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{HOUR}:%{MINUTE}:%{SECOND},%{INT})\s+%{LOGLEVEL:log_level}\s+\[%{DATA:thread_name}\]\s+%{NOTSPACE:logger_class}:\s+%{GREEDYDATA:msg_body}"
      }
    }

    # 如果 msg_body 太長，截斷它，避免 ES 拒絕索引 keyword 欄位
    if [msg_body] {
      ruby {
        code => "
          if event.get('msg_body').length > 5000
            event.set('msg_body', event.get('msg_body')[0..4999] + '... [TRUNCATED]')
          end
        "
      }
    }

    # 2. 時間處理 (修正逗號問題)
    date {
      # 注意這裡使用 (,) SSS
      match => [ "log_raw_date", "yyyy-MM-dd HH:mm:ss,SSS" ]
      target => "@timestamp"
      timezone => "Asia/Taipei"
    }
  }

  # =======================================================
  # 通用清理區塊 (所有 Log 都執行) 改 Fingerprint 
  # =======================================================
  # 去重複機制
  # 使用 message (內容) + @timestamp (時間) 來計算唯一碼
  fingerprint {
    source => ["message", "@timestamp"]
    target => "[@metadata][fingerprint]"
    method => "SHA256"
    concatenate_sources => true
  }
    
  mutate {
    # 移除解析用的暫存欄位
    remove_field => ["log_raw_date"]

    # 移除 Metadata (節省空間)
    remove_field => [
      "@version", "event.original", "[event][original]",
      "[agent][version]", "[agent][ephemeral_id]", "[agent][id]", "[agent][type]", "[agent][name]",
      "[ecs][version]", "[input][type]", "[log][offset]", "[log][file][path]",
      "[host][mac]", "[host][ip]", "[host][os]", "[host][architecture]", "[host][id]", "[host][containerized]",
      "message"
    ]
  }
}

output {
  elasticsearch {
    hosts => ["https://localhost:9200"]
    index => "%{env}-logs-%{+YYYY.MM.dd}"
    user => "elastic"
    password => "elastic"
    ssl_enabled => true
    ssl_certificate_authorities => "/data/elasticsearch/logstash-8.15.3/http_ca.crt"

    # 強制使用算出來的雜湊值當作 ID
    document_id => "%{[@metadata][fingerprint]}"
  }
  stdout { codec => rubydebug }
}